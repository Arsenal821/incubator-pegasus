# 使用stepworker只是做上下文管理
# 因此执行机都是本机

# 检查表是否有读写流
pre_check:
  class_name: PreCheckStep
  hosts: execute
  # 有count_data 操作时间长一些
  # 这是保底超时 后面会在程序里面动态更改
  timeout: 7200

# 建新表，名字带时间后缀
create_new_table:
  class_name: CreateNewTableStep
  hosts: execute
  
# 从老表拷贝到新表
copy_data:
  class_name: CopyDataStep
  hosts: execute
  # 有copy_data 操作时间长一些
  # 这是保底超时 后面会在程序里面动态更改
  timeout: 7200

# 删除老表
drop_old_table:
  class_name: DropTableStep
  hosts: execute
  # drop table会立刻返回 而实际上replica server并不一定真的关闭了所有实例 如果立刻recall会有问题
  # 因此需要人肉sleep一下 sleep时长与分片相关 分片不超过256个 因此对应超时时间调整为15分钟
  timeout: 900

# 恢复老表，恢复名带时间后缀
recall_old_table:
  class_name: RecallTableStep
  hosts: execute
  constructor_args:
      from_table_type: old
      to_use_time_prefix: true
  timeout: 1200

# 删除新表
drop_new_table:
  class_name: DropTableStep
  hosts: execute
  constructor_args:
      from_table_type: new
      use_time_prefix: true
  # drop table会立刻返回 而实际上replica server并不一定真的关闭了所有实例 如果立刻recall会有问题
  # 因此需要人肉sleep一下 sleep时长与分片相关 分片不超过256个 因此对应超时时间调整为15分钟
  timeout: 900

# 恢复新表，恢复名不带后缀
recall_new_table:
  class_name: RecallTableStep
  hosts: execute
  constructor_args:
      from_table_type: new
      to_use_time_prefix: false
  timeout: 1200

# 检查条数
post_check:
  class_name: PostCheckStep
  hosts: execute
  # 有count_data 操作时间长一些
  # 这是保底超时 后面会在程序里面动态更改
  timeout: 7200
